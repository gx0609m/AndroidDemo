WebView
    简介：
        Android中的一个组件，用来加载网页 ——— Android手机中内置了一个webkit内核浏览器；
        Android在不同版本中采用了不同的webkit内核，4.4后直接使用了Chrome内核，因此，不同android版本使用WebView时也有些许不同；


    功能：
        1.加载网页；
        2.Android与JS交互的桥梁；


    使用：
        1.添加权限：
            AndroidManifest.xml中添加 "android.permission.INTERNET" 权限，否则会报 Web page not available 错误；

        2.在Activity中生成一个WebView组件：
            a.WebView webView = new WebView(this)；
            b.在activity的layout文件里添加WebView控件，然后 mWebView=(WebView)findViewById(R.id.mWebView)；

        3.设置webView基本信息；
            a.WebSettings；
            b.WebViewClient ——— 处理各种通知、请求事件；
            c.WebChromeClient ——— 处理 Javascript 的对话框,网站图标,网站标题等；

        4.加载要显示的网页：
            a.加载网页：
                webView.loadUrl("https://www.baidu.com/");
            b.加载apk包中的页面 ——— 文件存放在assets文件夹（src/main/assets，与java文件夹同级）中：
                webView.loadUrl("file:///android_asset/XX.html");
            c.加载手机内存中的页面：
                webView.loadUrl("content://com.android.htmlfileprovider/sdcard/test.html");  //用的很少


    与JS交互：
        1.Android调JS方法：
            a.webView.loadUrl("javascript:XX()")；

            b.webView.evaluateJavascript("javascript:XX()", new ValueCallback<String>() {       // 可以获取JS方法的返回值
                       @Override
                       public void onReceiveValue(String value) {
                              Log.e(TAG, "JS方法的返回值是：" + value);
                       }
              })；

            需要注意的是：
                1>.loadUrl()方法会刷新页面，
                   evaluateJavascript()不会使页面刷新，
                   因此，evaluateJavascript()的效率更高、性能更好；
                2>.evaluateJavascript() 需要 minSDKVersion >= 19 ——— Android 4.4；
                3>.JS代码调用一定要在 onPageFinished() 回调之后才能调用，否则不会被调用；
                   因此，如果是在onPageFinished()回调之前，evaluateJavascript() 是获取不到JS的返回值的；

            使用建议：
                分版本混合使用，如下：
                        if (Build.VERSION.SDK_INT < 18) {
                            webView.loadUrl("javascript:callJS()");
                        } else {
                            webView.evaluateJavascript（"javascript:callJS()", new ValueCallback<String>() {
                                @Override
                                public void onReceiveValue(String value) {
                                    // js 返回的结果
                                }
                            });
                        }

        2.JS调Android方法：
            a.通过WebView的addJavascriptInterface()进行对象映射；
                1>.设置与JS交互的权限：
                    webSettings.setJavaScriptEnabled(true);  //支持js

                2>.定义一个与JS对象映射的Android类 ——— JsCallAndroid：
                        // js通信类
                        public class JsCallAndroid {
                            Context context;

                            public JsCallAndroid(Context c) {
                                context = c;
                            }

                            @JavascriptInterface  // Android 4.2+ 以上，只有添加了此注解，才会被JS方法调用
                            public void XX(String type) {
                                Log.e("tag","JS调了Android的XX()方法，同时传了一个String类型的值："+type);
                            }
                        }

                3>.通过WebView设置Android类与JS代码的映射：
                     webView.addJavascriptInterface(new JsCallAndroid(), "test"); // JsCallAndroid类对象映射到JS中的test对象

                4>.在JS代码中，通过test.XX()方法调用Android中的XX()方法；

                优点：使用简单，只需将Android对象和JS对象映射即可；

                缺点：存在严重的安全漏洞 ——— Android 4.2 以下可通过反射执行Android本地代码；

            b.通过WebViewClient的shouldOverrideUrlLoading()方法回调拦截Url；
                原理：
                    1>.通过WebViewClient的回调方法shouldOverrideUrlLoading()拦截url；
                    2>.解析该 url 的协议；
                    3>.如果检测到是预先约定好的协议，就调用相应方法，即实现了JS调用Android方法；

                步骤：
                    1>.在JS约定所需要的Url协议；
                            // 约定的url协议为：js://webview?arg1=111&arg2=222
                            document.location = "js://webview?arg1=111&arg2=222";

                    2>.重写shouldOverrideUrlLoading()方法；
                            /**
                            * 通过拦截Url来实现JS调用Android方法
                            */
                            @Override
                            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                                /*
                                 * 根据协议的参数，判断是否是所需要的url
                                 * 一般根据scheme（协议格式） & authority（协议名）判断（前两个参数）
                                 * 假定传入进来的 url = "js://webview?arg1=111&arg2=222"（同时也是约定好的需要拦截的）
                                 */
                                 Uri uri = Uri.parse(url);
                                 // 如果url的协议 = 预先约定的 js 协议，就解析往下解析参数
                                 if (uri.getScheme().equals("js")) {
                                     // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议
                                     if (uri.getAuthority().equals("webview")) {  ----------------------------  以下即为步骤3逻辑
                                         /*
                                          * 执行JS所需要调用的逻辑
                                          * 可以在协议上带有参数并传递到Android上
                                          */
                                         // 获取参数值
                                         String param1Value = uri.getQueryParameter("arg1");
                                         String param2Value = uri.getQueryParameter("arg2");
                                         Log.e(TAG, "两个参数值分别为：" + "参数1：" + param1Value + "参数2：" + param2Value); // 两个参数值分别为111、222
                                         // 获取参数名
                                         Set<String> collection = uri.getQueryParameterNames();
                                         // 从set中取出指定位置的元素，通过将Set转换成List，再取值
                                         List<String> list = new ArrayList<String>(collection);
                                         if (list.size() >= 2) {
                                             // 调用Android中的方法
                                             JSCallAndroidWithUrlIntercept(list.get(0), list.get(1)); // 两个参数名分别为arg1、arg2
                                         }
                                     }
                                     return true;
                                 }
                                 return super.shouldOverrideUrlLoading(view, url);
                             }

                    3>.拦截Url，截取判断，都符合约定的协议时，即可执行相应逻辑 ——— 调用Android中的方法；

            c.通过WebChromeClient的onJsAlert()、onJsConfirm()、onJsPrompt()方法回调拦截JS对话框alert()、confirm()、prompt()消息；


    性能优化：
        1.优化网页加载速度：

        2.避免WebView内存泄露：


    漏洞处理：
        起因：
            2013年Android平台暴露出WebView漏洞，攻击者可以通过存在风险的addJavascriptInterface接口函数，利用反射执行Android本地代码，造成很大的风险；

            如果你使用的是AndroidStudio，在你的webSettings.setJavaScriptEnabled(true)这句代码中，AndroidStudio会给你一个提示：
                "Using setJavaScriptEnabled can introduce XSS vulnerabilities into your application,review carefully.
                 Your code should not invoke setJavaScriptEnabled if you are not sure that your app really requires JavaScript support."
            这个漏洞在Android 4.2上已经修复了，通过使用@JavascriptInterface这个注解；

            但是从兼容性方面考虑，不能保证每个用户使用的都是4.2+的系统；
            所以基本上我们不会再利用Android系统为我们提供的addJavascriptInterface()、@JavascriptInterface注解来实现js和java的通信了；
            那怎么办呢？

        处理方式：
            1.Android 4.2+：
                使用@JavascriptInterface注解；


