Property Animation
    简介：
        为了解决补间动画等的缺陷，系统在 Android 3.0（API 11） 后开始提供的一种全新动画模式；


    背景：
        Android系统一开始提供的两种实现动画的方式 ——— 逐帧动画 & 补间动画 存在一定的缺点，例如：
            1.作用对象局限于 View：
                补间动画 只能够作用在视图View上，即只可以对一个
                    Button、
                    TextView、
                    甚至是 LinearLayout、
                    或者其它 继承自View 的组件、
                进行动画操作，但无法对非View的对象进行动画操作；

                但有些情况下的动画效果只是视图的某个 属性 & 对象 而不是整个视图，如：
                    现需要实现视图的颜色动态变化，那么就需要操作视图的颜色属性从而实现动画效果，而不是针对整个视图进行动画操作；

            2.没有改变View的属性，只是改变视觉效果：
                补间动画只是改变了View的视觉效果，而不会真正去改变View的属性，如：
                    将屏幕左上角的按钮 通过补间动画 移动到屏幕的右下角，
                    点击当前按钮位置（屏幕右下角）是没有效果的，
                    因为实际上按钮还是停留在屏幕左上角，补间动画只是将这个按钮绘制到屏幕右下角，改变了视觉效果而已；

            3.动画效果单一：
                补间动画只能实现 平移、旋转、缩放、透明度 这些简单的动画需求；
                即在 功能 & 可扩展性 有较大局限；


    特点：
        1.作用对象 ——— 不只是View对象，可以是任意Java对象，甚至没对象也可以；
        2.动画效果 ——— 不只是4种基本的补间动画变换，还有其他动画效果；
        3.作用领域 ——— API 11 后引入；


    原理：
        在一定时间间隔内，通过不断对值进行改变，同时不断的将该值赋给对象的属性，从而实现 该对象 在 该属性 上的动画效果；
            可以是任意对象的任意属性，但这个属性须提供 初始值 & setXX() 方法，如果没有初始值，则须提供 getXX() 方法；

        工作流程图：
            ——— res/flowchart/property_animation.png；

            由工作流程图可以看到，属性动画有两个非常重要的类
                ——— ValueAnimator类 & ObjectAnimator类；


    ValueAnimator类：
        实现动画的原理：
            ——— 通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果；

        工作流程图：
            ——— res/flowchart/value_animator.png；

            从 工作流程图 可看出，ValueAnimator类有三个重要的方法：
                a.ValueAnimator.ofInt(int values)；
                b.ValueAnimator.ofFloat(float values)；
                c.ValueAnimator.ofObject(int values)；
            下面逐一介绍这三个方法：

        ValueAnimator.ofInt(int... values)：
            作用：
                将初始值 以整型数值的形式 过渡到结束值，即估值器是 整型估值器 ——— IntEvaluator；

            工作流程图：
                ——— res/flowchart/value_animator_ofInt.png；

            具体使用：
                由于 ValueAnimator 本质只是一种 值 的操作机制，因此这里只先介绍 如何改变一个值 的过程，
                至于如何实现动画，是需要开发者 手动 将这些 值 赋给 对象的属性值，
                关于这部分会稍后再做说明；

                操作值的方式 分为 XML设置 / Java 代码设置：
                    Java代码设置 ——— valueAnimatorWithOfIntByJava()：
                        实际开发中，建议使用Java代码实现属性动画：因为很多时候属性的起始值是无法提前确定的（无法使用XML设置），这就需要在Java代码里动态获取；
                        1>.设置动画属性的 初始值 & 结束值；
                            /*
                             * ofInt()作用有两个：
                             *     1>.创建动画实例；
                             *     2>.将传入的多个Int参数进行平滑过渡：
                             *          此处传入0和10,表示将值从0平滑过渡到10；
                             *          如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推；
                             *          ValueAnimator.ofInt()内置了整型估值器,直接采用默认的，不需要设置，即默认设置了如何从 初始值 过渡到 结束值；
                             */
                            ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 10);

                        2>.设置动画的各种播放属性；
                            valueAnimator.setDuration(1000);                        // 设置动画运行的时长
                            valueAnimator.setStartDelay(500);                       // 设置动画延迟播放时间
                            valueAnimator.setRepeatCount(0);                        // 设置动画重复播放次数 = 重放次数+1，动画播放次数 = infinite 时,动画无限重复
                            valueAnimator.setRepeatMode(ValueAnimator.RESTART);     // 设置重复播放动画模式，ValueAnimator.RESTART(默认):正序播放；ValueAnimator.REVERSE:倒序回放

                        3>.将改变的值手动赋值给对象的属性值 ——— 通过动画的更新监听器 AnimatorUpdateListener；
                        4>.将改变后的值赋给对象的属性值 ——— View.setProperty(currentValue)；
                        5>.刷新视图，即重新绘制，从而实现动画效果 ——— View.requestLayout()；
                            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                                @Override
                                public void onAnimationUpdate(ValueAnimator animation) {
                                    int currentValue = (Integer) animation.getAnimatedValue();  // 获得改变后的值
                                    Log.d(TAG, currentValue + "");                              // 输出改变后的值
                                    /*
                                     * 4.将改变后的值赋给对象的属性值 ——— View.setProperty(currentValue)
                                     */
                                    valueAnimatorOfInt.setTextSize(currentValue);
                                    /*
                                     * 5.刷新视图，即重新绘制，从而实现动画效果 ——— View.requestLayout()
                                     */
                                    valueAnimatorOfInt.requestLayout();
                                }
                            });

                        6>.启动动画；
                            valueAnimator.start();

                    XML设置：
                        具备重用性，即将通用的动画写到XML里，可在各个界面中去重用它；
                        1>.在路径 res/animator 的文件夹里创建相应的动画 value_animation_ofint.xml 文件：

                        2>.设置动画参数：
                            具体属性参见 value_animation_ofint.xml；

                        3>.在Java代码中启动动画：
                            Animator animator = AnimatorInflater.loadAnimator(this, R.animator.value_animation_ofint);  // 载入XML动画
                            animator.setTarget(valueAnimatorOfInt);                                                     // 设置动画对象
                            animator.start();                                                                           // 启动动画
                            这里并没有实现和Java代码一样的 TextView 中 字体大小 变化的动画效果，
                            因为 Animator 类暂时不能添加 AnimatorUpdateListener，只能添加 AnimatorListener & AnimatorListenerAdapter；

            ofInt(int... values)源码分析：
                /*
                 * 允许传入一个或多个 Int 参数：
                 *     输入一个的情况（如a）——— 从0过渡到a；
                 *     输入多个的情况（如a，b，c）——— 先从a平滑过渡到b，再从b平滑过渡到C；
                 */
                public static ValueAnimator ofInt(int... values) {
                    ValueAnimator anim = new ValueAnimator();                           // 创建动画对象实例
                    anim.setIntValues(values);                                          // 将传入的值赋值给这个动画对象实例
                    return anim;                                                        // 返回这个动画对象实例
                }

        ValueAnimator.ofFloat(float... values)：
            作用：
                将 初始值 以浮点型数值的形式 过渡到结束值，即估值器是 浮点型估值器 ——— FloatEvaluator；

            工作流程图：
                ——— res/flowchart/value_animator_ofFloat.png；

            具体使用：
                由于 ValueAnimator 本质只是一种 值 的操作机制，因此这里只先介绍 如何改变一个值 的过程，
                至于如何实现动画，是需要开发者 手动 将这些 值 赋给 对象的属性值，
                关于这部分会稍后再做说明；

                操作值的方式 分为 XML设置 / Java 代码设置：
                    Java代码设置：
                        与 ValueAnimator.ofInt(int... values) 使用方法类似，只需将 ofInt(**) 替换为 ofFloat(**) 即可；

                    XML设置：
                        与 ValueAnimator.ofInt(int... values) 使用方法类似，xml 文件中同样是使用 <animator> 标签；

            与ofInt(**)比较：
                ValueAnimator.ofInt() 与 ValueAnimator.oFloat() 仅仅只是在估值器上的区别：（即如何从 初始值 过渡到 结束值）
                    a.ValueAnimator.oFloat() ——— 采用默认的 浮点型估值器 （FloatEvaluator）；
                    b.ValueAnimator.ofInt() ——— 采用默认的 整型估值器（IntEvaluator）；

        ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values)：
            作用：
                将初始值 以对象的形式 过渡到结束值；

            工作流程图：
                ——— res/flowchart/value_animator_ofObject.png；

            具体使用 ——— 只有 Java代码设置 方式：
                1>.创建 开始动画时的对象 & 结束动画时的对象；
                    MyObject startObject = new MyObject();                              // 开始动画时的对象
                    MyObject endObject = new MyObject();                                // 结束动画时的对象

                2>.创建 ValueAnimator 动画对象；
                    /*
                     * 参数1 ——— 自定义的估值器对象（TypeEvaluator 类型参数）；
                     * 参数2 ——— 开始动画的对象；
                     * 参数3 ——— 结束动画的对象；
                     */
                    ValueAnimator valueAnimator = ValueAnimator.ofObject(new myObjectEvaluator(), startObject, endObject);

                3>.设置动画的各种播放属性；
                    valueAnimator.setDuration(1000);                        // 设置动画运行的时长
                    valueAnimator.setStartDelay(500);                       // 设置动画延迟播放时间
                    ...
                    ...

                4>.启动动画；
                    valueAnimator.start();
















（https://www.jianshu.com/p/2412d00a0ce4）
