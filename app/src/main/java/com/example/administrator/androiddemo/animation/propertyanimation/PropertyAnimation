Property Animation
    简介：
        为了解决补间动画等的缺陷，系统在 Android 3.0（API 11） 后开始提供的一种全新动画模式；


    背景：
        Android系统一开始提供的两种实现动画的方式 ——— 逐帧动画 & 补间动画 存在一定的缺点，例如：
            1.作用对象局限于 View：
                补间动画 只能够作用在视图View上，即只可以对一个
                    Button、
                    TextView、
                    甚至是 LinearLayout、
                    或者其它 继承自View 的组件、
                进行动画操作，但无法对非View的对象进行动画操作；

                但有些情况下的动画效果只是视图的某个 属性 & 对象 而不是整个视图，如：
                    现需要实现视图的颜色动态变化，那么就需要操作视图的颜色属性从而实现动画效果，而不是针对整个视图进行动画操作；

            2.没有改变View的属性，只是改变视觉效果：
                补间动画只是改变了View的视觉效果，而不会真正去改变View的属性，如：
                    将屏幕左上角的按钮 通过补间动画 移动到屏幕的右下角，
                    点击当前按钮位置（屏幕右下角）是没有效果的，
                    因为实际上按钮还是停留在屏幕左上角，补间动画只是将这个按钮绘制到屏幕右下角，改变了视觉效果而已；

            3.动画效果单一：
                补间动画只能实现 平移、旋转、缩放、透明度 这些简单的动画需求；
                即在 功能 & 可扩展性 有较大局限；


    特点：
        1.作用对象 ——— 不只是View对象，可以是任意Java对象，甚至没对象也可以；
        2.动画效果 ——— 不只是4种基本的补间动画变换，还有其他动画效果；
        3.作用领域 ——— API 11 后引入；


    原理：
        在一定时间间隔内，通过不断对值进行改变，同时不断的将该值赋给对象的属性，从而实现 该对象 在 该属性 上的动画效果；
            可以是任意对象的任意属性，但这个属性须提供 初始值 & setXX() 方法，如果没有初始值，则须提供 getXX() 方法；

        工作流程图：
            ——— res/flowchart/property_animation.png；

            由工作流程图可以看到，属性动画有两个非常重要的类
                ——— ValueAnimator类 & ObjectAnimator类；


    ValueAnimator类：
        实现动画的原理：
            ——— 通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果；

        工作流程图：
            ——— res/flowchart/value_animator.png；

            从 工作流程图 可看出，ValueAnimator类有三个重要的方法：
                a.ValueAnimator.ofInt(int values)；
                b.ValueAnimator.ofFloat(float values)；
                c.ValueAnimator.ofObject(int values)；
            下面逐一介绍这三个方法：

        ValueAnimator.ofInt(int... values)：
            作用：
                将初始值 以整型数值的形式 过渡到结束值，即估值器是 整型估值器 ——— IntEvaluator；

            工作流程图：
                ——— res/flowchart/value_animator_ofInt.png；

            具体使用：
                由于 ValueAnimator 本质只是一种 值 的操作机制，因此这里只先介绍 如何改变一个值 的过程，
                至于如何实现动画，是需要开发者 手动 将这些 值 赋给 对象的属性值，
                关于这部分会稍后再做说明；

                操作值的方式 分为 XML设置 / Java 代码设置：
                    Java代码设置 ——— valueAnimatorWithOfIntByJava()：
                        实际开发中，建议使用Java代码实现属性动画：因为很多时候属性的起始值是无法提前确定的（无法使用XML设置），这就需要在Java代码里动态获取；
                        1>.设置动画属性的 初始值 & 结束值；
                            /*
                             * ofInt()作用有两个：
                             *     1>.创建动画实例；
                             *     2>.将传入的多个Int参数进行平滑过渡：
                             *          此处传入0和10,表示将值从0平滑过渡到10；
                             *          如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推；
                             *          ValueAnimator.ofInt()内置了整型估值器,直接采用默认的，不需要设置，即默认设置了如何从 初始值 过渡到 结束值；
                             */
                            ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 10);

                        2>.设置动画的各种播放属性；
                            valueAnimator.setDuration(1000);                        // 设置动画运行的时长
                            valueAnimator.setStartDelay(500);                       // 设置动画延迟播放时间
                            valueAnimator.setRepeatCount(0);                        // 设置动画重复播放次数 = 重放次数+1，动画播放次数 = infinite 时,动画无限重复
                            valueAnimator.setRepeatMode(ValueAnimator.RESTART);     // 设置重复播放动画模式，ValueAnimator.RESTART(默认):正序播放；ValueAnimator.REVERSE:倒序回放

                        3>.将改变的值手动赋值给对象的属性值 ——— 通过动画的更新监听器 AnimatorUpdateListener；
                        4>.将改变后的值赋给对象的属性值 ——— View.setProperty(currentValue)；
                        5>.刷新视图，即重新绘制，从而实现动画效果 ——— View.requestLayout()；
                            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                                @Override
                                public void onAnimationUpdate(ValueAnimator animation) {
                                    int currentValue = (Integer) animation.getAnimatedValue();  // 获得改变后的值
                                    Log.d(TAG, currentValue + "");                              // 输出改变后的值
                                    /*
                                     * 4.将改变后的值赋给对象的属性值 ——— View.setProperty(currentValue)
                                     */
                                    valueAnimatorOfInt.setTextSize(currentValue);
                                    /*
                                     * 5.刷新视图，即重新绘制，从而实现动画效果 ——— View.requestLayout()
                                     */
                                    valueAnimatorOfInt.requestLayout();
                                }
                            });

                        6>.启动动画；
                            valueAnimator.start();

                    XML设置：
                        具备重用性，即将通用的动画写到XML里，可在各个界面中去重用它；
                        1>.在路径 res/animator 的文件夹里创建相应的动画 value_animation_ofint.xml 文件：

                        2>.设置动画参数：
                            具体属性参见 value_animation_ofint.xml；

                        3>.在Java代码中启动动画：
                            Animator animator = AnimatorInflater.loadAnimator(this, R.animator.value_animation_ofint);  // 载入XML动画
                            animator.setTarget(valueAnimatorOfInt);                                                     // 设置动画对象
                            animator.start();                                                                           // 启动动画
                            这里并没有实现和Java代码一样的 TextView 中 字体大小 变化的动画效果，
                            因为 Animator 类暂时不能添加 AnimatorUpdateListener，只能添加 AnimatorListener & AnimatorListenerAdapter；

            ofInt(int... values)源码分析：
                /*
                 * 允许传入一个或多个 Int 参数：
                 *     输入一个的情况（如a）——— 从0过渡到a；
                 *     输入多个的情况（如a，b，c）——— 先从a平滑过渡到b，再从b平滑过渡到C；
                 */
                public static ValueAnimator ofInt(int... values) {
                    ValueAnimator anim = new ValueAnimator();                           // 创建动画对象实例
                    anim.setIntValues(values);                                          // 将传入的值赋值给这个动画对象实例
                    return anim;                                                        // 返回这个动画对象实例
                }

        ValueAnimator.ofFloat(float... values)：
            作用：
                将 初始值 以浮点型数值的形式 过渡到结束值，即估值器是 浮点型估值器 ——— FloatEvaluator；

            工作流程图：
                ——— res/flowchart/value_animator_ofFloat.png；

            具体使用：
                由于 ValueAnimator 本质只是一种 值 的操作机制，因此这里只先介绍 如何改变一个值 的过程，
                至于如何实现动画，是需要开发者 手动 将这些 值 赋给 对象的属性值，
                关于这部分会稍后再做说明；

                操作值的方式 分为 XML设置 / Java 代码设置：
                    Java代码设置：
                        与 ValueAnimator.ofInt(int... values) 使用方法类似，只需将 ofInt(**) 替换为 ofFloat(**) 即可；

                    XML设置：
                        与 ValueAnimator.ofInt(int... values) 使用方法类似，xml 文件中同样是使用 <animator> 标签；

            与ofInt(**)比较：
                ValueAnimator.ofInt() 与 ValueAnimator.oFloat() 仅仅只是在估值器上的区别：（即如何从 初始值 过渡到 结束值）
                    a.ValueAnimator.oFloat() ——— 采用默认的 浮点型估值器 （FloatEvaluator）；
                    b.ValueAnimator.ofInt() ——— 采用默认的 整型估值器（IntEvaluator）；

        ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values)：
            作用：
                将初始值 以对象的形式 过渡到结束值；

            工作流程图：
                ——— res/flowchart/value_animator_ofObject.png；

            具体使用 ——— 只有 Java代码设置 方式：
                1>.创建 开始动画时的对象 & 结束动画时的对象；
                    MyObject startObject = new MyObject();                              // 开始动画时的对象
                    MyObject endObject = new MyObject();                                // 结束动画时的对象

                2>.创建 ValueAnimator 动画对象；
                    /*
                     * 参数1 ——— 自定义的估值器对象（TypeEvaluator 类型参数）；
                     * 参数2 ——— 开始动画的对象；
                     * 参数3 ——— 结束动画的对象；
                     */
                    ValueAnimator valueAnimator = ValueAnimator.ofObject(new myObjectEvaluator(), startObject, endObject);

                3>.设置动画的各种播放属性；
                    valueAnimator.setDuration(1000);                        // 设置动画运行的时长
                    valueAnimator.setStartDelay(500);                       // 设置动画延迟播放时间
                    ...
                    ...

                4>.启动动画；
                    valueAnimator.start();


    估值器（TypeEvaluator）：
        作用：
            设置动画如何从 初始值 过渡到 结束值 的 变化逻辑，决定 值 的具体变化数值；

        分类：
            ValueAnimator.ofInt()    ————  IntEvaluator         整形估值器     ————    系统内置；
            ValueAnimator.ofFloat()  ————  FloatEvaluator       浮点型估值器   ————     系统内置；
            ValueAnimator.ofObject() ————  MyObjectEvaluator    对象估值器     ————    自定义；

            以 ValueAnimator.ofFloat() 为例，
                它实现了 “将初始值 以浮点型的形式 过渡到结束值”  的逻辑，那么这个 过渡逻辑 具体是怎么样的呢？

            其实，
                是系统内置了一个 FloatEvaluator 估值器，内部实现了 初始值 与 结束值 以 浮点型 的过渡逻辑；

            我们可以看下 FloatEvaluator 的代码，如下：
                /**
                 * FloatEvaluator 实现了 TypeEvaluator 接口
                 */
                public class FloatEvaluator implements TypeEvaluator<Number> {
                    /*
                     * 重写 evaluate()
                     *    fraction：表示动画完成度（根据它来计算当前动画的值）；
                     *    startValue、endValue：动画的初始值和结束值；
                     */
                    public Float evaluate(float fraction, Number startValue, Number endValue) {
                        /*
                         * 初始值 过渡到 结束值 的算法是：
                         *     1>.用结束值减去初始值，算出它们之间的差值；
                         *     2>.用上述差值乘以fraction系数；
                         *     3>.再加上初始值，就得到当前动画的值；
                         */
                        float startFloat = startValue.floatValue();
                        return startFloat + fraction * (endValue.floatValue() - startFloat);
                    }
                }

            ValueAnimator.ofInt() & ValueAnimator.ofFloat() 都具备系统内置的估值器，即 FloatEvaluator & IntEvaluator；

            但对于 ValueAnimator.ofObject()，从上面的工作原理可以看出，
                并没有系统默认实现，
                因为对对象的动画操作复杂 & 多样，
                系统无法知道如何从初始对象过度到结束对象，
            因此，对于 ValueAnimator.ofObject()，我们需自定义估值器（TypeEvaluator）来告知系统如何进行从 初始对象 过渡到 结束对象的逻辑；

            自定义估值器的实现逻辑如下：
                /*
                 * 实现TypeEvaluator接口
                 */
                public class MyObjectEvaluator implements TypeEvaluator{
                    /*
                     * 复写evaluate（），在evaluate（）里写入对象动画过渡的逻辑
                     * 参数说明：
                     *     fraction：表示动画完成度（根据它来计算当前动画的值）；
                     *     startValue、endValue：动画的初始值和结束值；
                     */
                    @Override
                    public Object evaluate(float fraction, Object startValue, Object endValue) {
                        /*
                         * 写入对象动画过渡的逻辑
                         */
                        ...

                        return value;   // 返回对象动画过渡的逻辑计算后的值
                    }

        实例说明自定义估值器的步骤：
            要实现的动画效果 ———— 一个圆从一个点 移动到 另外一个点：
                自定义 TypeEvaluator 接口并通过 ValueAnimator.ofObject() 实现动画效果；

            步骤：
                1>.定义对象类；
                   由于 ValueAnimator.ofObject() 是面向对象操作的，所以需要自定义对象类，
                   本例需要操作的对象是 圆的点坐标，所以定义：
                       Point.java

                2>.根据需求 自定义估值器 实现 TypeEvaluator 接口；
                   实现 TypeEvaluator 接口的目的是 自定义如何 从初始点坐标 过渡 到结束点坐标，本例实现的是一个从左上角到右下角的坐标过渡逻辑；

                   PointEvaluator.java
                       public class PointEvaluator implements TypeEvaluator {
                           /*
                            * 实现 TypeEvaluator 接口，并复写 evaluate()
                            *      fraction：表示动画完成度（根据它来计算当前动画的值）
                            *      startValue、endValue：动画的初始值和结束值；
                            */
                           @Override
                           public Object evaluate(float fraction, Object startValue, Object endValue) {

                               // 将 动画初始值startValue 和 动画结束值endValue 强制类型转换成 Point 对象
                               Point startPoint = (Point) startValue;
                               Point endPoint = (Point) endValue;

                               // 根据fraction来计算当前动画的 x & y 的值
                               float x = startPoint.getX() + fraction * (endPoint.getX() - endPoint.getX());
                               float y = startPoint.getY() + fraction * (endPoint.getY() - endPoint.getY());

                               // 将计算后的坐标封装到一个新的Point对象中并返回
                               Point point = new Point(x, y);
                               return point;
                           }
                       }


    插值器（Interpolator）：
        作用：
            设置动画如何从 初始值 过渡到 结束值 的 变化模式，决定 值 的具体变化模式（匀速、加减速 等~）；







（https://www.jianshu.com/p/2412d00a0ce4）
